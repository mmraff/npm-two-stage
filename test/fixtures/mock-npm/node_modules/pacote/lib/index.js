/*
  manifest return value properties referenced:
  * version, name, _resolved, _integrity in RegistryItemAgent case
  * _resolved, _integrity (optional), _sha, _allRefs, _from in GitItemAgent case
  * _resolved in UrlItemAgent case (use of _integrity commented out; TODO)
*/
const Emitter = require('events')
const path = require('path')
const ssri = require('ssri')
const npa = require('npm-package-arg')

function mockError(code) {
  const err = new Error("mock pacote error")
  err.code = code
  return err
}

const errorStates = {
  manifest: { doThrow: false },
  tarball: { doThrow: false }
}

const waitStates = {
  manifest: {},
  tarball: {}
}

const knownPackages = {}
const notifier = new Emitter()

const pacote = module.exports = {
  setErrorState: (fnName, state, code) => {
    if (!errorStates[fnName])
      throw new SyntaxError(`Unrecognized method name "${fnName}"`)
    errorStates[fnName].doThrow = state
    errorStates[fnName].code = code
  },

  setTestConfig: (data) => {
    for (let p in knownPackages) delete knownPackages[p]
    if (!data) return
    if (typeof data != 'object')
      throw new TypeError('Configuration data must be an object')
    for (let p in data) knownPackages[p] = data[p]
  },

// TODO: rewrite the wait state stuff to be like what we did for v6, because
// it's less lines and more elegant
  setWait: (fnName, spec) => {
    const waiting = waitStates[fnName]
    if (!waiting[spec]) waiting[spec] = true
  },
  endWait: (fnName, spec) => {
    const waiting = waitStates[fnName]
    if (!waiting[spec]) return
    waiting[spec] = false
    notifier.emit('endwait', fnName, spec)
  },

  manifest: (spec, opts) => {
    if (waitStates.manifest[spec]) {
//console.log('OOPS, we have a waitState')
      return new Promise((resolve, reject) => {
        const myHandler = (fnName, otherSpec) => {
          if (fnName != 'manifest' || otherSpec != spec) return
          notifier.removeListener('endwait', myHandler)
          if (errorStates.manifest.doThrow)
            return reject(mockError(errorStates.manifest.code))
          const data = knownPackages[spec]
          if (data) {
            if (!data._integrity) data._integrity = ssri.mockIntegrity()
            resolve(data)
          }
          else reject(new Error(`Unknown package: ${spec}`))
        }
        notifier.on('endwait', myHandler)
      })
    }
    // Else there's no wait.
    if (errorStates.manifest.doThrow)
      return Promise.reject(mockError(errorStates.manifest.code))

    const data = knownPackages[spec]
    if (data) {
      if (!data._integrity) data._integrity = ssri.mockIntegrity()
      return Promise.resolve(data)
    }
    else {
      const npaSpec= npa(spec)
      if (npaSpec.type == 'directory') {
        const pjPath = path.join(spec, 'package.json')
        const msg = `ENOENT: no such file or directory, open '${pjPath}'`
        return Promise.reject(new Error(msg))
      }
    }
    return Promise.reject(new Error(`Unknown package: ${spec}`))
  },
  // As a function, tarball is not used, so we only need to support tarball.file()
  tarball: {}
}

module.exports.tarball.file = (spec, dest, opts) => {
  const maybeRes = {
    integrity: opts.integrity,
    resolved: opts.resolved,
    from: spec
  }
  if (waitStates.tarball[spec]) {
    return new Promise((resolve, reject) => {
      const myHandler = (fnName, otherSpec) => {
        if (fnName != 'tarball' || otherSpec != spec) return
        notifier.removeListener('endwait', myHandler)
        if (errorStates.tarball.doThrow)
          reject(mockError(errorStates.tarball.code))
        else resolve(maybeRes)
      }
      notifier.on('endwait', myHandler)
    })
  }

  if (errorStates.tarball.doThrow)
    return Promise.reject(mockError(errorStates.tarball.code))

  return Promise.resolve(maybeRes)
}
/*
  Actual pacote.tarball.file resolves to an object with some manifest values
  BUT - item-agents ignores the resolved value
*/
