const errorCfg = { throwIt: false }

const testCfg = {}

/*
  (So far) The actual package that this mocks is only used by git-aux,
  so it only needs to handle the packument of a git repo.
  The packument has { versions, 'dist-tags', name }.
  'wanted' is npaSpec.gitRange.
  'opts' is passed along to pacote/lib/util/git;
  no props referenced in my code except 'multipleRefs'
*/
module.exports = function(packument, wanted, opts) {
  if (errorCfg.throwIt) {
    const err = new Error('Dummy error from npm-pick-manifest mock')
    if (errorCfg.code) err.code = errorCfg.code
    throw err
  }
  if (!testCfg[packument.name])
    //throw new Error(`Not configured for package named "${packument.name}"`)
    // Instead of throwing a test-related message, return null, so we can
    // get that last bit of coverage
    return null

  const keys = testCfg[packument.name]
  // keys.section will be 'versions' or 'refs';
  // keys.ref will be a property name in that section.
  // The return value will be the refData associated with that property.
  const result = packument[keys.section][keys.ref]
  return result
}

module.exports.setErrorState = (fnName, state, errCode) => {
  errorCfg.throwIt = state
  errorCfg.code = errCode
}

/*
  pickManifest will receive a remoteRefs (git packument) document, and we
  only need to decide what to pick from it. So the function that configures
  for a test just needs to be told the keys to use to pick the intended
  result... examples: { versions: '2.2.2' } or { refs: 'master' }
*/
module.exports.setTestConfig = function(data) {
  for (const key in testCfg)
    delete testCfg[key]
  if (data && data.name)
    testCfg[data.name] = data.keys
}
