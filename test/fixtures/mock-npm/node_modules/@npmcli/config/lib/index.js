/*
  N2SMOCK: REDUCED
  Config is required by mock npm.js and by definitions.js, which is
  one of the changed files in npm-two-stage.
*/
const { homedir } = require('os')
const { dirname } = require('path')

const typeDefs = require('./type-defs.js')

// Copied from npm/lib/utils/config/definitions.js:
// basic flattening function, just copy it over camelCase
const flatten = (key, obj, flatOptions) => {
  const camel = key.replace(/-([a-z])/g, (_0, _1) => _1.toUpperCase())
  flatOptions[camel] = obj[key]
}

const _loaded = Symbol('mockConfigLoaded')
const _settings = Symbol('mockConfigSettings')
const _defaults = Symbol('mockConfigDefaults')
const _flatOptions = Symbol('mockConfigFlatOptions')

const cfgDefaults = {
  'audit-level': null,
  'dl-dir': null,
  'force': false,
  'global': false,
  'ignore-scripts': false,
  'include': [],
  'location': 'user',
  'lockfile-dir': null,
  'offline': false,
  'offline-dir': null,
  'omit': [],
  'package-json': null,
  'package-lock': true,
  'prefix': '',
  'script-shell': null,
}

class Config {
  static get typeDefs () {
    return typeDefs
  }

  constructor ({
    args = {
      include: [],
      omit: [],
    }, // <-- THIS is where we pass command line opts for tests
    opts = {}, // <-- THIS is where we pass ... ?
    env = {},
    argv = [], // Not really needed; just an attempt to conform with actual
    log, // trust for now...
    platform = process.platform,
    execPath = process.execPath,
    cwd = process.cwd(),
    npmPath,
  }) {
    this[_defaults] = cfgDefaults
    this[_flatOptions] = null

    this.npmPath = npmPath
    this.log = log
    this.argv = argv
    this.env = env
    this.execPath = execPath
    this.platform = platform
    this.cwd = cwd

    // This replaces loadCLI(), which is called from load() in the actual:
    this[_settings] = { ...args }

    this[_loaded] = false
  }

  get loaded () { // VERBATIM
    return this[_loaded]
  }

  get prefix () { // *Almost* verbatim
    return this.get('global') ? this.globalPrefix : this.localPrefix
  }

  // Implementation of this in the actual class has a 2nd arg, and
  // error checks are done on it, but we don't need any of that here.
  get (item) {
    if (!this.loaded) {
      throw new Error('call config.load() before reading values')
    }
    return item in this[_settings] ?
      this[_settings][item] : this[_defaults][item]
  }

  set (item, value) {
    if (!this.loaded) {
      throw new Error('call config.load() before setting values')
    }
    this[_settings][item] = value
    // the flat options are invalidated, regenerate next time they're needed
    this[_flatOptions] = null
  }

  get flat () { // Follows original, but deviant
    if (this[_flatOptions]) {
      return this[_flatOptions]
    }

    this[_flatOptions] = {}
    // Note: iterating the settings and defaults separately allows us to
    // cover settings items that don't have a default (e.g. 'J')
    for (const opt in this[_settings]) {
      flatten(opt, this[_settings], this[_flatOptions])
      // Treat cases of custom flatten methods:
      switch (opt) {
        case 'script-shell':
          if (!this[_flatOptions].scriptShell) { // default is null
            this[_flatOptions].scriptShell = undefined
          }
          break
      }
    }
    for (const opt in this[_defaults]) {
      if (opt in this[_settings]) continue

      flatten(opt, this[_defaults], this[_flatOptions])
      // Treat cases of custom flatten methods:
      switch (opt) {
        case 'global':
          if (this[_flatOptions].global) {
            this[_flatOptions].location = 'global'
          }
          break
        case 'location':
          if (this[_flatOptions].global) {
            this[_flatOptions].location = 'global'
          }
          if (this[_settings].location === 'global') { // default is 'user'
            this[_flatOptions].global = true
          }
          break
        case 'script-shell':
          if (!this[_flatOptions].scriptShell) { // default is null
            this[_flatOptions].scriptShell = undefined
          }
          break
      }
    }
    return this[_flatOptions]
  }

  // This method in the actual class is asynchronous. We don't need that for
  // the mock, because this only gets called in tests, and here we do nothing
  // that is async.
  // This gets called by mock npm; it can also be called in a test to get
  // the dependent properties recomputed. <-- TODO: drop that
  load () {
    if (this.loaded) {
      throw new Error('attempting to load npm config multiple times')
    }

    this.loadGlobalPrefix()
    this[_defaults].prefix = this.globalPrefix
    this.loadLocalPrefix()

    this[_loaded] = true

    // The load method in the actual class actually has this line,
    // as weird as it looks, given the loadGlobalPrefix() call above.
    // It comes after a series of loadXXX calls that may change the prefix.
    this.globalPrefix = this.get('prefix')
  }

  // TODO: see if it's easy to convert our tests to use a fresh npm (& config)
  // each time, so that we can make this throw on reload just like the real thing.
  // The actual loadGlobalPrefix throws if called more than once.
  // Here we don't prevent multiple calls, because this is the only way
  // to get the globalPrefix set correctly after setting this.global.
  loadGlobalPrefix () { // *Almost* verbatim (reduced)
    if (this.globalPrefix) {
      throw new Error('cannot load default global prefix more than once')
    }

    if (this.env.PREFIX) {
      // TODO: if this feature is never used by our tests, delete it
      this.globalPrefix = this.env.PREFIX
    } else if (this.platform === 'win32') {
      // 'c:\node\node.exe' --> prefix='c:\node\'
      this.globalPrefix = dirname(this.execPath)
    } else {
      // '/usr/local/bin/node' --> prefix='/usr/local'
      this.globalPrefix = dirname(dirname(this.execPath))

      // destdir only is respected on Unix
      if (this.env.DESTDIR) {
        this.globalPrefix = join(this.env.DESTDIR, this.globalPrefix)
      }
    }
  }

  loadLocalPrefix () { // Following the lead of actual, but stripped down
    const cliPrefix = this[_settings].prefix
    if (cliPrefix) {
      this.localPrefix = cliPrefix
      return
    }

    // Walking-up-dirs removed from here.

    this.localPrefix = this.cwd
  }
}

module.exports = Config
