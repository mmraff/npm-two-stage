const { promisify } = require('util')
const mkdirAsync = promisify(require('fs').mkdir)
const path = require('path')
const stream = require('stream')

const rimrafAsync = promisify(require('rimraf'))

const errorStates = {
  putStream: { doThrow: false }
}

function mockError(code) {
  const err = new Error('mock cacache error')
  if (code) err.code = code
  return err
}

// In actual module, put is a function that returns Promise -> integrity value
// but we don't use it in alt-git except as the parent of 'stream', below
module.exports.put = {}
module.exports.put.stream = (cache, key, opts = {}) => {
  // returns a minipass-pipeline (a kind of stream?)
  const w = new stream.Writable({
    write: function(chunk, encoding, cb) {
      if (errorStates.putStream.doThrow)
        return cb(mockError(errorStates.putStream.code))
      //console.log('The writable _write was called with:', chunk) // confirmed
      this.emit('data', 'ignore this')
      cb()
    }
  })
  w.promise = function() {
    return new Promise((resolve, reject) => {
      w.on('finish', () => {
        //console.log('The writable emitted "finish"') // confirmed
        resolve('ok')
      })
      w.on('error', e => reject(e))
    })
  }
  return w
}

module.exports.tmp = {}
module.exports.tmp.withTmp = (cache, opts, cb) => {
  /*
    From ultimate source, @npmcli/fs (see @npmcli/fs/lib/with-temp-dir.js):
    "create a temp directory, ensure its permissions match its parent, then call
     the supplied function passing it the path to the directory. clean up after
     the function finishes, whether it throws or not"
    Note that this fails to mention that when the supplied function returns a
    Promise, the resolved value of that is supposed to be returned by the
    cleanup thenable! Unnecessary tail chaser caused by poor documentation!
  */
  const tmpName = 'repo' + (Math.floor(Math.random() * 900000) + 100000)
  const tmpPath = path.resolve(__dirname, '../../..', 'tmp', tmpName)
  return mkdirAsync(tmpPath).then(() => cb(tmpPath))
  .then(result => {
    rimrafAsync(tmpPath)
    return result
  })
}

module.exports.setErrorState = function(fnName, state, code) {
  if (!errorStates[fnName])
    throw new SyntaxError(`Unrecognized method name "${fnName}"`)
  errorStates[fnName].doThrow = state
  errorStates[fnName].code = code
}
