const fs = require('fs')
const path = require('path')
const url = require('url')
const { promisify } = require('util')
const copyFileAsync = promisify(fs.copyFile)
const writeFileAsync = promisify(fs.writeFile)

const mockReadPkgJson = require('read-package-json-fast')

/*
  errors (object): These are more-or-less verbatim from @npmcli/git errors.js.
  GitPathspecError is the only one referenced specifically in alt-git, but we
  don't get full coverage unless we conditionally return at least one other.
*/
class GitConnectionError extends Error {
  constructor (message) {
    super('A git connection error occurred')
  }
}
class GitPathspecError extends Error {
  constructor (message) {
    super('The git reference could not be found')
  }
}
class GitUnknownError extends Error {
  constructor (message) {
    super('An unknown git error occurred')
  }
}

module.exports.errors = {
  GitConnectionError,
  GitPathspecError,
  GitUnknownError
}

const knownRepos = {}
const knownTmpFiles = {}
const errStates = {
  clone: { throwIt: false }
}

module.exports.setErrorState = (fnName, state, errClass) => {
  errStates[fnName].throwIt = state
  errStates[fnName].classObject = errClass || GitUnknownError
}

module.exports.setTestConfig = (data) => {
  for (let prop in knownRepos) delete knownRepos[prop]
  Object.assign(knownRepos, data)
}

module.exports.clone = function(repo, ref = 'HEAD', tmp, opts) {
  // repo is a URL. Always. No abbreviated specs here.
  // where opts contains a spec property: a npaResult.
  if (errStates.clone.throwIt) {
    // The custom error classes as given have built-in messages
    return Promise.reject(new errStates.clone.classObject())
  }

  const repoData = knownRepos[repo]
  if (!repoData) {
    if (opts.speak) {
      const keys = Object.keys(knownRepos)
      console.log(`git.clone says knownRepos does not include repo ${repo}; but...`)
      console.log('keys:', keys)
    }
    return Promise.reject(new Error(`404: Unreachable address ${repo}`))
  }

  knownTmpFiles[tmp] = repo
  mockReadPkgJson.setTestConfig({
    // Make a copy, else our cached data gets contaminated when the receiver
    // adds a property (_shrinkwrap) to it:
    [path.join(tmp, 'package.json')]: { ...repoData.pkgJson }
  })
  const destPath = path.join(tmp, 'npm-shrinkwrap.json')
  return (repoData.shrinkwrapPath ?
    copyFileAsync(repoData.shrinkwrapPath, destPath) :
    repoData.badShrinkwrap ?
      writeFileAsync(destPath, 'Not a shrinkwrap.') :
      Promise.resolve())
    .then(() => repoData.manifest._sha)
}

module.exports.revs = function(dirUrl, opts) {
  // The only place this gets called (that I've discovered so far) is in
  // AltGitFetcher[_clone], where it is only ever passed a file:// URL.
  // dirUrl comes from [_clone]'s use of url.pathToFileURL(tmp), which gives a
  // file URL, instead of the key we used above in clone()
  const tmpKey = url.parse(dirUrl).path
  const repoKey = knownTmpFiles[tmpKey]
  if (!repoKey)
    return Promise.reject(new Error(`Unrecognized temp directory ${dirUrl}`))
  const revsDoc = knownRepos[repoKey].revsDoc
  return Promise.resolve(revsDoc)
}
