const npa = require('npm-package-arg')

const available = new Set()
// This is not a feature of actual pacote; but we need it to help manifest()
// simulate what happens when the specified package cannot be found:
module.exports.addTestSpec = function(spec) {
  if (typeof spec == 'string') available.add(spec)
  else if (typeof spec == 'object' && spec.raw) available.add(spec.raw)
  else throw new TypeError(`Does not look like a package spec: ${spec}`)
}

const cfg = {
  manifest: { throwIt: false },
  extract: { throwIt: false }
}

module.exports.setErrorState = (fnName, state, errCode, nullStack) => {
  if (!cfg[fnName])
    throw new Error(`Unrecognized export "${fnName}", can't setErrorState`)
  cfg[fnName].throwIt = state
  cfg[fnName].code = errCode
  cfg[fnName].nullStack = nullStack
}

module.exports.manifest = function(spec, opts) {
  if (cfg.manifest.throwIt) {
    const err = new Error('Dummy error from pacote mock')
    if (cfg.manifest.code) err.code = cfg.manifest.code
    if (cfg.manifest.nullStack)
      err.stack = null
    return Promise.reject(err)
  }

  if (!opts) opts = {}
  let p = Promise.resolve()
  const newSpec = npa(spec, opts.where)
  if (newSpec.type != 'file')
    if (!available.has(newSpec.raw))
      return Promise.reject(
        new Error('TODO: find out exactly what error pacote gives in the case of NO SUCH')
      )
  return p.then(() => {
    const manifest = {}
    if (opts.annotate) {
      manifest._from = newSpec.saveSpec || newSpec.raw
      manifest._requested = newSpec
      manifest._spec = newSpec.raw
      manifest._where = opts.where
    }
    return manifest
  })
}

module.exports.extract = function(spec, tgtPath, opts) {
  if (cfg.extract.throwIt) {
    const err = new Error('Dummy error from pacote mock')
    if (cfg.extract.code) err.code = cfg.extract.code
    if (cfg.extract.nullStack)
      err.stack = ''
    return Promise.reject(err)
  }

  return Promise.resolve()
}

