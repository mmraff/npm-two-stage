const errorCfg = { throwIt: false }

const testCfg = {}

// (So far) The actual package that this mocks is only used by git-aux,
// so it only needs to handle the packument of a git repo.
// The packument has { versions, 'dist-tags', name }.
// 'wanted' is npaSpec.gitRange. 'opts' is passed in, and passed along to
// pacote/lib/util/git; no props referenced in my code except 'multipleRefs'
module.exports = function(packument, wanted, opts) {
  if (errorCfg.throwIt) {
    const err = new Error('Dummy error from npm-pick-manifest mock')
    if (errorCfg.code) err.code = errorCfg.code
    throw err
  }
  if (!testCfg[packument.name])
    //throw new Error(`Not configured for package named "${packument.name}"`)
  // Instead of throwing a test-related message, return null, so we can
  // get that last bit of coverage
    return null

  const keys = testCfg[packument.name]
  // keys.section will be 'versions' or 'refs';
  // keys.ref will be a property name in that section.
  // The return value will be the refData associated with that property.
  const result = packument[keys.section][keys.ref]
  return result
}

module.exports.setErrorState = (fnName, state, errCode) => {
  errorCfg.throwIt = state
  errorCfg.code = errCode
}

/*
  TODO: CUT TO THE CHASE...
  We will receive a remoteRefs (git packument) document, and we just need
  to decide what to pick from it. npm-pick-manifest is small, but still I
  think that it's inappropriate to install it as a dev dep. So the function
  that configures for a test just needs to be told the keys to use to pick
  the intended result... examples: { versions: '2.2.2' } or { refs: 'master' }
*/
module.exports.setTestConfig = function(data) {
  for (const key in testCfg)
    delete testCfg[key]
  if (data && data.name)
    testCfg[data.name] = data.keys
}


/*
  This is what we get for the call
    pacote.manifest(
      'bitbucket:mmraff/shrinkwrapped-project',
      { annotate:true, hashAlgorithm:'sha1', cache:path.join(process.env.APPDATA,'npm-cache')}
    ):
Manifest {
  name: 'shrinkwrapped-project',
  version: '0.0.1',
  engines: undefined,
  cpu: undefined,
  os: undefined,
  dependencies:
   { 'not-so-empty-project': 'bitbucket:mmraff/not-so-empty-project#1086f3c379b8fad3e7aac0fc0002863950ed15d7' },
  optionalDependencies: {},
  peerDependenciesMeta: {},
  devDependencies: {},
  bundleDependencies: false,
  peerDependencies: {},
  deprecated: false,
  _resolved: 'bitbucket:mmraff/shrinkwrapped-project#13f9636c54e75660bafd6acd00db61621e7d193c',
  _integrity: null,
  _shasum: null,
  _shrinkwrap:
   { name: 'shrinkwrapped-project',
     version: '0.0.1',
     lockfileVersion: 1,
     requires: true,
     dependencies: { 'empty-project': [Object], 'not-so-empty-project': [Object] } },
  _id: 'shrinkwrapped-project@0.0.1',
  _from: 'bitbucket:mmraff/shrinkwrapped-project',
  _requested:
   Result {
     type: 'git',
     registry: undefined,
     where: undefined,
     raw: 'bitbucket:mmraff/shrinkwrapped-project',
     name: undefined,
     escapedName: undefined,
     scope: undefined,
     rawSpec: 'bitbucket:mmraff/shrinkwrapped-project',
     saveSpec: 'bitbucket:mmraff/shrinkwrapped-project',
     fetchSpec: null,
     gitRange: undefined,
     gitCommittish: null,
     hosted:
      GitHost {
        type: 'bitbucket',
        protocols: [Array],
        domain: 'bitbucket.org',
        treepath: 'src',
        tarballtemplate: 'https://{domain}/{user}/{project}/get/{committish}.tar.gz',
        sshtemplate: 'git@{domain}:{user}/{project}.git{#committish}',
        sshurltemplate: 'git+ssh://git@{domain}/{user}/{project}.git{#committish}',
        browsetemplate: 'https://{domain}/{user}/{project}{/tree/committish}',
        browsefiletemplate: 'https://{domain}/{user}/{project}/{treepath}/{committish}/{path}{#fragment}',
        docstemplate: 'https://{domain}/{user}/{project}{/tree/committish}#readme',
        httpstemplate: 'git+https://{auth@}{domain}/{user}/{project}.git{#committish}',
        filetemplate: 'https://{domain}/{user}/{project}/raw/{committish}/{path}',
        shortcuttemplate: '{type}:{user}/{project}{#committish}',
        pathtemplate: '{user}/{project}{#committish}',
        pathmatch: /^[\/]([^\/]+)[\/]([^\/]+?)(?:[.]git|[\/])?$/,
        hashformat: [Function: formatHashFragment],
        protocols_re: /^(git\+ssh|git\+https|ssh|https):$/,
        user: 'mmraff',
        auth: null,
        project: 'shrinkwrapped-project',
        committish: null,
        default: 'shortcut',
        opts: [Object] } },
  _spec: 'bitbucket:mmraff/shrinkwrapped-project',
  _where: undefined }

  Underneath the hood, it makes a call like this (utilGit is pacote/lib/util/git):
    const npaSpec = npa('bitbucket:mmraff/shrinkwrapped-project')
    utilGit.revs(npaSpec.hosted.https())

  and the result is
{ versions: {},
  'dist-tags': {},
  refs:
   { master:
      { sha: '13f9636c54e75660bafd6acd00db61621e7d193c',
        ref: 'master',
        type: 'branch' } },
  shas: { '13f9636c54e75660bafd6acd00db61621e7d193c': [ 'master' ] } }

  This is important because git-aux resolve() makes the same utilGit call.
  The following is the result of utilGit.revs(repoPathFileURL):
 { versions: {},
  'dist-tags': {},
  refs:
   { master:
      { sha: '13f9636c54e75660bafd6acd00db61621e7d193c',
        ref: 'master',
        type: 'branch' } },
  shas: { '13f9636c54e75660bafd6acd00db61621e7d193c': [ 'master' ] } }

  WHAT FIELDS GET USED BY THE CONSUMER?
  First, *if there's a non-empty gitRange in the npaSpec* (so that it counts as a semver tag),
  parts of remoteRefs (the revs() result) are passed to pickManifest(
    versions: remoteRefs.versions,
    'dist-tags': remoteRefs['dist-tags'],
    name: name
  )
  Where the result is ref,
  fetchManifest (via plainManifest) creates a manifest in which
  * the _resolved field is made from npaSpec.saveSpec with the hash replaced/added by ref.sha
  * _uniqueResolved is a copy of that
  * _ref is ref
  * there are other fields, but they're not derived from ref.

  When I call pickManifest() with data from a more complex packument
  (see SCRATCH/OUTPUT_CAPTURES/pacote_fetchers_git_resolve.txt),
  and supply a gitRange that matches something in that data, I get
{ sha: 'ca3c95b022ecaaea188069564b996c93c9c86483',
ref: 'v2.2.1',
type: 'tag' }
*/
