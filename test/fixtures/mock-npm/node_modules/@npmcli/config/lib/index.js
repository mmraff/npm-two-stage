/*
  N2SMOCK: REDUCED
  Config is required by npm.js (real and mock)
*/

const { homedir } = require('os')
const { dirname, join } = require('path')

const nopt = require('nopt')

const typeDefs = require('./type-defs.js')
const envReplace = require('./env-replace.js')
const parseField = require('./parse-field.js')

// Copied from npm/lib/utils/config/definitions.js:
// basic flattening function, just copy it over camelCase
const defaultFlatten = (key, obj, flatOptions) => {
  const camel = key.replace(/-([a-z])/g, (_0, _1) => _1.toUpperCase())
  flatOptions[camel] = obj[key]
}
// Specialized flattener for cache
const flattenCache = (obj, flatOptions) => {
  flatOptions.cache = join(obj.cache, '_cacache')
  // TODO: don't know that these are ever used in tests:
  flatOptions.npxCache = join(obj.cache, '_npx')
  flatOptions.tufCache = join(obj.cache, '_tuf')
}

const cfgDefaults = {
  'audit-level': null,
  'dl-dir': null,
  'force': false,
  'global': false,
  'ignore-scripts': false,
  'include': [],
  'location': 'user',
  'lockfile-dir': null,
  'offline': false,
  'offline-dir': null,
  'omit': [],
  'package-json': null,
  'package-lock': true,
  'prefix': '',
  'script-shell': null,
  'user-agent': 'npm/{npm-version} node/{node-version} {platform} {arch} workspaces/{workspaces} {ci}',
  'workspace': [],
}

class Config {
  #loaded = false
  #flatten
  #flatOptions = null
  #defaults = cfgDefaults
  #settings

  static get typeDefs () {
    return typeDefs
  }

  // definitions.js declares default paths for the cache and its children,
  // but those are outside our test sandbox. We want to provide a way for
  // the current test to make Config instances use a temporary location
  // set up for this.
  static set defaultCache (loc) {
    cfgDefaults.cache = loc
  }

  constructor ({
    args = {}, // <-- THIS is where we pass command line opts for tests
    opts = {}, // <-- THIS is where we pass ... ?
    env = {},
    platform = process.platform,
    execPath = process.execPath,
    cwd = process.cwd(),
    // These items are passed by actual npm:
    definitions,
    shorthands,
    flatten,
    npmPath,
    argv = [],
  }) {
    // Actual constructor extracts types from the definitions
    if (definitions) {
      this.definitions = definitions
      const types = {}
      for (const [key, def] of Object.entries(definitions)) {
        types[key] = def.type
      }
      this.types = types
    }
    this.#flatten = flatten

    this.npmPath = npmPath
    this.argv = argv
    this.env = env
    this.execPath = execPath
    this.platform = platform
    this.cwd = cwd
    this.localPackage = 'MOCK_CONFIG_DUMMY_LOCALPACKAGE'

    this.#settings = { ...args }
  }

  get loaded () { // verbatim
    return this.#loaded
  }

  get prefix () { // *Almost* verbatim
    return this.get('global') ? this.globalPrefix : this.localPrefix
  }

  find (key) { // Needed by npm_test
    if (!this.loaded) {
      throw new Error('call config.load() before reading values')
    }
    return key in this.#settings ? 'cli'
      : key in this.#defaults ? 'default'
      : null
  }

  // Implementation of this in the actual class has a 2nd arg, and
  // error checks are done on it, but we don't need any of that here.
  get (item) {
    if (!this.loaded) {
      throw new Error('call config.load() before reading values')
    }
    return item in this.#settings ?
      this.#settings[item] : this.#defaults[item]
  }

  set (item, value, where = 'cli') {
    if (!this.loaded) {
      throw new Error('call config.load() before setting values')
    }
    this.#settings[item] = value
    // the flat options are invalidated, regenerate next time they're needed
    this.#flatOptions = null
  }

  get flat () { // Follows original, but deviant
    if (this.#flatOptions) {
      return this.#flatOptions
    }

    this.#flatOptions = {}
    if (this.definitions && this.#flatten) {
      this.#flatten({ ...this.#defaults, ...this.#settings }, this.#flatOptions)
    }
    else {
      // Note: iterating the settings and defaults separately allows us to
      // cover settings items that don't have a default (e.g. 'J')
      for (const opt in this.#settings) {
        defaultFlatten(opt, this.#settings, this.#flatOptions)
        // Treat cases of custom flatten methods:
        switch (opt) {
          case 'script-shell':
            if (!this.#flatOptions.scriptShell) { // default is null
              this.#flatOptions.scriptShell = undefined
            }
            break
          case 'cache':
            flattenCache(this.#settings, this.#flatOptions)
            break
        }
      }
      for (const opt in this.#defaults) {
        if (opt in this.#settings) continue

        defaultFlatten(opt, this.#defaults, this.#flatOptions)
        // Treat cases of custom flatten methods:
        switch (opt) {
          case 'cache':
            flattenCache(this.#defaults, this.#flatOptions)
            break
          case 'global':
            if (this.#flatOptions.global) {
              this.#flatOptions.location = 'global'
            }
            break
          case 'location':
            if (this.#flatOptions.global) {
              this.#flatOptions.location = 'global'
            }
            if (this.#settings.location === 'global') { // default is 'user'
              this.#flatOptions.global = true
            }
            break
          case 'script-shell':
            if (!this.#flatOptions.scriptShell) { // default is null
              this.#flatOptions.scriptShell = undefined
            }
            break
        }
      }
    }
    return this.#flatOptions
  }

  async load () {
    if (this.loaded) {
      throw new Error('attempting to load npm config multiple times')
    }

    this.loadCLI()
    this.loadGlobalPrefix()
    this.#defaults.prefix = this.globalPrefix
    this.loadLocalPrefix()

    this.#loaded = true

    // The load method in the actual class actually has this line,
    // as weird as it looks, given the loadGlobalPrefix() call above.
    // It comes after a series of loadXXX calls that may change the prefix.
    this.globalPrefix = this.get('prefix')

    return Promise.resolve() // mmr: only to be consistent with async decl
  }

  loadGlobalPrefix () { // *Almost* verbatim (reduced)
    if (this.globalPrefix) {
      throw new Error('cannot load default global prefix more than once')
    }

    if (this.env.PREFIX) {
      this.globalPrefix = this.env.PREFIX
    } else if (this.platform === 'win32') {
      // 'c:\node\node.exe' --> prefix='c:\node\'
      this.globalPrefix = dirname(this.execPath)
    } else {
      // '/usr/local/bin/node' --> prefix='/usr/local'
      this.globalPrefix = dirname(dirname(this.execPath))

      // destdir only is respected on Unix
      if (this.env.DESTDIR) {
        this.globalPrefix = join(this.env.DESTDIR, this.globalPrefix)
      }
    }
  }

  loadCLI () { // Guided by actual, but reduced + incorporating loadObject
    if (!this.definitions) return // Only do the following for npm_test

    const conf = nopt(this.types, this.shorthands, this.argv)
    this.parsedArgv = conf.argv
    delete conf.argv

    const cfg = { raw: conf }
    for (const [key, value] of Object.entries(conf)) {
      const k = envReplace(key, this.env)
      const v = this.parseField(value, k)
      // Deprecations check removed from here
      this.#settings[k] = v
    }
  }

  // Parse a field, coercing it to the best type available.
  parseField (f, key, listElement = false) { // verbatim
    return parseField(f, key, this, listElement)
  }

  loadLocalPrefix () { // Following the lead of actual, but stripped down
    const cliPrefix = this.#settings.global ? this.#settings.prefix : null
    if (cliPrefix) {
      this.localPrefix = cliPrefix
      return
    }

    // Walking-up-dirs and lots of workspace stuff removed from here.
    // TODO: find out from new tests whether we need to put back any of that.

    if (!this.localPrefix) {
      this.localPrefix = this.cwd
    }
  }
}

module.exports = Config
