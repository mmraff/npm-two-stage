const Emitter = require('events')
const fs = require('fs')
const { promisify } = require('util')
const readFileAsync = promisify(fs.readFile)

const npa = require('npm-package-arg')

const knownPackages = {}

// Created this for an early test suite. (More than one?)
// It's not enough for the needs of the download test suite.
module.exports.addTestSpec = function(spec) {
  if (typeof spec == 'string') knownPackages[spec] = {}
  else if (typeof spec == 'object' && spec.raw) knownPackages[spec.raw] = {}
  else throw new TypeError(`Does not look like a package spec: ${spec}`)
}
module.exports.addTestMetadata = function(spec, data) {
  if (typeof spec == 'string') knownPackages[spec] = data
  else if (typeof spec == 'object' && spec.raw) knownPackages[spec.raw] = data
  else throw new TypeError(`Does not look like a package spec: ${spec}`)
}
module.exports.purgeTestData = function() {
  for (let key in knownPackages) delete knownPackages[key]
}

const cfg = {
  manifest: { throwIt: false },
  tarball: { throwIt: false },
  extract: { throwIt: false }
}

module.exports.setErrorState = (fnName, state, errCode, nullStack) => {
  if (!cfg[fnName])
    throw new Error(`Unrecognized export "${fnName}", can't setErrorState`)
  cfg[fnName].throwIt = state
  cfg[fnName].code = errCode
  cfg[fnName].nullStack = nullStack
}

module.exports.setWait = fnName => {
  if (!cfg[fnName].wait)
    cfg[fnName].wait = []
}

module.exports.endWait = fnName => {
  const waitList = cfg[fnName].wait
  if (!waitList) return
  for (let i = 0; i < waitList.length; ++i)
    waitList[i].emit('endwait')
  delete cfg[fnName].wait
}

module.exports.manifest = function(spec, opts) {
  if (cfg.manifest.throwIt) {
    const err = new Error('manifest error from mock pacote')
    if (cfg.manifest.code) err.code = cfg.manifest.code
    if (cfg.manifest.nullStack)
      err.stack = null
    return Promise.reject(err)
  }

  if (!opts) opts = {}
  const newSpec = npa(spec, opts.where)
  let p
  if (newSpec.type != 'file')
    if (!(newSpec.raw in knownPackages)) {
      return Promise.reject(
        new Error('404 from mock pacote.manifest: ' + newSpec.raw)
      )
    }

  return (p || Promise.resolve()).then(() => {
    const manifest = Object.assign({}, knownPackages[newSpec.raw])
    if (opts.annotate) {
      manifest._from = newSpec.saveSpec || newSpec.raw
      manifest._requested = newSpec
      manifest._spec = newSpec.raw
      manifest._where = opts.where
    }
    return manifest
  })
}

// TODO: the real version of this creates a tarball file (and resolves to nothing).
// There should be a way for this module to 'remember' that this was called, so
// that it can be checked for the expected 'side effect'.
module.exports.tarball = {}
module.exports.tarball.toFile = function(spec, filepath, opts) {
  const waiter = new Emitter()
  const p = new Promise((resolve, reject) => {
    if (cfg.tarball.throwIt) {
      const err = new Error('tarball.toFile error from mock pacote')
      if (cfg.tarball.code) err.code = cfg.tarball.code
      if (cfg.tarball.nullStack)
        err.stack = null
      waiter.on('endwait', () => reject(err))
    }
    waiter.on('endwait', () => resolve())
  })
  if (cfg.tarball.wait) cfg.tarball.wait.push(waiter)
  else waiter.emit('endwait')
  return p
}

module.exports.extract = function(spec, tgtPath, opts) {
  if (cfg.extract.throwIt) {
    const err = new Error('extract error from mock pacote')
    if (cfg.extract.code) err.code = cfg.extract.code
    if (cfg.extract.nullStack)
      err.stack = ''
    return Promise.reject(err)
  }
  return Promise.resolve()
}

