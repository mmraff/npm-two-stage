const YarnLock = require('../src/download/alt-yarn-lock')

const t = require('tap')
const { resolve, basename } = require('path')
const arbFixturesPath = 'fixtures/arborist/fixtures'
const fixtures = [
  resolve(__dirname, arbFixturesPath, 'tap-with-yarn-lock'),
  resolve(__dirname, arbFixturesPath, 'yarn-stuff'),
]
const { readFileSync } = require('fs')

fixtures.forEach(f => t.test(basename(f), t => {
  const lockdata = readFileSync(f + '/yarn.lock')
  const yarnLock = new YarnLock()
  // parse the data
  yarnLock.parse(lockdata)
  // then turn it into output
  const lockOutput = yarnLock.toString()
  // snapshot the result
  t.matchSnapshot(lockOutput, 'generated output from input')
  const yarnLock2 = new YarnLock()
  yarnLock2.parse(lockOutput)
  t.strictSame(yarnLock2, yarnLock, 'same parsed result from string output')
  t.end()
}))

t.test('invalid data in a property value does not throw', t => {
  // data adapted from package-lock.json of fixture install-types-sw-only:
  const badVersion = 'url:// not even close to a ! valid @ npm @ specifier'
  const badResolved = 'this: is: also: not: valid!#123456789abcdef'
  const yarnText = [
    '"really-bad-invalid":',
    `  version "${badVersion}"`,
    `  resolved "${badResolved}"`,
    ''
  ].join('\n')
  let yarnObj
  t.doesNotThrow(() => yarnObj = YarnLock.parse(yarnText))
  for (const entry of yarnObj.entries) {
    // entry[0] is a spec, such as 'mkdirp@^1.0.2'.
    // entry[1] is a YarnLockEntry object.
    t.equal(
      entry[1].resolved, badResolved.replace(/ /g, ''),
      '"resolved" value has spaces removed, otherwise not changed'
    )
  }
  t.end()
})

t.test('invalid yarn lockfile format throws', t => {
  t.throws(() => YarnLock.parse(`
asdf@foo:
  this !is not vlid
            i mean
what even is it??
   not yarn lock, that's for sure
      {"maybe":"json"}?
 - or: even
 - yaml?
 - NO
`), {content: '  this !is not vlid\n', line: 3, position: 11}, 'just garbage')

  t.throws(() => YarnLock.parse(`
asdf@foo:
  dependencies:
    foo bar baz blork
`), {content: '    foo bar baz blork\n', line: 4}, 'invalid subkey')

  t.end()
})

t.test('omits empty dependency list on toString output', t => {
  const y = new YarnLock()
  y.parse(`
foo@bar:
  version "1.2.3"
  resolved "https://registry.local/foo/-/foo-1.2.3.tgz"
  dependencies:

# Note: do not require a \\n at the end of the file, just add it if missing
# Also: comments are not preserved.

bar@foo:
  version "1.2.3"`)
  t.equal(y.toString(), `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1


bar@foo:
  version "1.2.3"

foo@bar:
  version "1.2.3"
  resolved "https://registry.local/foo/-/foo-1.2.3.tgz"
`)
  t.end()
})

t.test('exports YarnLockEntry class', t => {
  t.type(YarnLock.Entry, 'function')
  t.end()
})

