/*
  Config is required by mock npm.js and by definitions.js, which is
  one of the changed files in npm-two-stage.
*/
const { homedir } = require('os')
const { dirname } = require('path')

const typeDefs = require('./type-defs.js')

// TODO: this needs to be absorbed into the constructor
const hyphenItems = {
  'ignore-scripts': 'ignoreScripts',
  'script-shell': 'scriptShell',
  'offline-dir': 'offlineDir',
  'package-json': 'packageJson'
}

class Config {
  static get typeDefs () {
    return typeDefs
  }

  constructor ({
    flatten,
    // This is not used by install.js, but the real config uses it to load
    // settings from the npmrc file at the given path:
    npmPath,

    env = process.env,
    // TODO: I'm suspicious that process.argv in a test will not be like argv
    // when npm install is actually run:
    argv = process.argv,
    platform = process.platform,
    // TODO: this.execPath is used to determine this.globalPrefix, so it
    // should be set carefully, and maybe not like this:
    execPath = process.execPath,
    global,
    auditLevel,
    // Addition of npm-cli install tests to the suite revealed that their mock
    // of npm and @npmcli/config take a 'prefix' value to override the local
    // or global prefix:
    prefix,
    // this.cwd is used to determine this.localPrefix, so it should be passed
    // explicitly, and not set to process.cwd() as it is in the real thing:
    cwd,
    log,
    ignoreScripts,
    scriptShell,
    offlineDir,
  }) {
    if (!cwd)
      throw new SyntaxError('Working path (cwd) MUST BE passed to mock config')
    if (!log)
      throw new SyntaxError('log object MUST BE passed to mock config')
    this.flatten = flatten
    this.npmPath = npmPath
    this.env = env
    this.argv = argv
    this.platform = platform
    this.execPath = execPath
    this.global = global
    this.audit
    this.include = []
    this.omit = []
    this.cwd = cwd
    this.log = log
    this.ignoreScripts = ignoreScripts
    this.scriptShell = scriptShell
    if (offlineDir) this.offlineDir = offlineDir

    this.flat = {} // Needed by npm.flatOptions()

    // set when we load configs
    this.globalPrefix = null
    this.localPrefix = prefix || cwd
  }

  async load () {
    // mmraff NOTE: We don't prevent multiple calls to this, because a call to
    // this is the only way to get the globalPrefix set correctly after setting
    // this.global.
    this.loadGlobalPrefix()
    // mmraff NOTE: if not 'global', the following sets this.globalPrefix to
    // the localPrefix. Hence the reasoning above.
    this.globalPrefix = this.get('prefix')

    for (const item in this) {
      if (item == 'flat') continue
      if (this.hasOwnProperty(item)) this.flat[item] = this[item]
    }

    this.loaded = true
    return Promise.resolve()
  }

  loadGlobalPrefix () {
    if (this.env.PREFIX) {
      this.globalPrefix = this.env.PREFIX
    } else if (this.platform === 'win32') {
    // c:\node\node.exe --> prefix=c:\node\
      this.globalPrefix = dirname(this.execPath)
    } else {
      // /usr/local/bin/node --> prefix=/usr/local
      this.globalPrefix = dirname(dirname(this.execPath))

      // destdir only is respected on Unix
      if (this.env.DESTDIR)
        this.globalPrefix = join(this.env.DESTDIR, this.globalPrefix)
    }
  }

  get (item) {
    return item in hyphenItems ? this[hyphenItems[item]] : this[item]
  }

  set (item, value) {
    if (item in hyphenItems)
      this[hyphenItems[item]] = value
    else this[item] = value
  }

  get prefix () {
    return this.global ? this.globalPrefix : this.localPrefix
  }
}

module.exports = Config

